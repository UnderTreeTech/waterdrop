/*
 *
 * Copyright 2020 waterdrop authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Package dao contains the types for schema 'swoyii'.
package dao

// Code generated by xo. DO NOT EDIT.
import (
	"context"
	"errors"
	"fmt"

	"github.com/UnderTreeTech/waterdrop/examples/app/internal/model"

	"github.com/Masterminds/squirrel"
	"github.com/UnderTreeTech/waterdrop/pkg/database/sql"
	"github.com/UnderTreeTech/waterdrop/pkg/log"
)

/********************Generate By OX: write method segment*********************/
// Add the Shop to the database.
func (d *dao) AddShop(ctx context.Context, s *model.Shop) (err error) {
	// sql insert query, primary key provided by autoincrement
	sqlStr, args, err := squirrel.
		Insert(model.GetShopTableName()).
		Columns(model.GetShopFieldStringSlice()...).
		Values(model.GetShopAddField(s)...).
		ToSql()

	if err != nil {
		return
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "AddShop"), log.String("sql", fmt.Sprint(sqlStr, args)))
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		_, err = d.db.Exec(ctx, sqlStr, args...)
	} else {
		_, err = tx.Exec(sqlStr, args...)
	}

	return
}

// Batch Add the Shop to the database.
func (d *dao) BatchAddShops(ctx context.Context, list []*model.Shop) (err error) {
	if 0 == len(list) {
		return
	}

	if 50 < len(list) {
		return errors.New("batch operation supports up to 50")
	}

	// sql insert query, primary key provided by autoincrement
	sqlBuilder := squirrel.
		Insert(model.GetShopTableName()).
		Columns(model.GetShopFieldStringSlice()...)

	for _, s := range list {
		sqlBuilder = sqlBuilder.Values(model.GetShopAddField(s)...)
	}

	sqlStr, args, err := sqlBuilder.ToSql()
	if err != nil {
		return err
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "BatchAddShops"), log.String("sql", fmt.Sprint(sqlStr, args)))
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		_, err = d.db.Exec(ctx, sqlStr, args...)
	} else {
		_, err = tx.Exec(sqlStr, args...)
	}

	return
}

// Edit the Shop in the database.
func (d *dao) EditShop(ctx context.Context, setMap map[string]interface{}, condition map[string]interface{}) (err error) {
	// build sql
	sqlStr, args, err := squirrel.
		Update(model.GetShopTableName()).
		SetMap(setMap).
		Where(condition).
		ToSql()

	if err != nil {
		return
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "EditShop"), log.String("sql", fmt.Sprint(sqlStr, args)))
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		_, err = d.db.Exec(ctx, sqlStr, args...)
	} else {
		_, err = tx.Exec(sqlStr, args...)
	}

	return
}

// Delete the Shop from the database.
func (d *dao) DelShopById(ctx context.Context, id uint64) (err error) {
	// build sql
	sqlStr := `UPDATE ` + model.GetShopTableName() + ` SET is_del = 1 WHERE id = ?`

	// run query
	log.Info(ctx, "sql", log.String("event", "DelShopById"), log.String("sql", fmt.Sprint(sqlStr, id)))
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		_, err = d.db.Exec(ctx, sqlStr, id)
	} else {
		_, err = tx.Exec(sqlStr, id)
	}

	return
}

/******************Generate By OX: read method segment**********************/
// Find one the Shop from the database.
func (d *dao) FindShop(ctx context.Context, condition map[string]interface{}) (res *model.Shop, err error) {
	// init build
	build := squirrel.Select(model.GetShopFieldString()).From(model.GetShopTableName())

	// forced master database query
	force := false
	if _, ok := condition["_force"]; ok {
		force = true
		delete(condition, "_force")
	}

	// build sql
	build, err = d.Analytic(build, condition)
	if err != nil {
		return
	}

	sqlStr, args, err := build.ToSql()
	if err != nil {
		return
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "FindShop"), log.String("sql", fmt.Sprint(sqlStr, args)))
	res = &model.Shop{}
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		if force {
			err = d.db.Master().QueryRow(ctx, sqlStr, args...).Scan(model.GetShopScanField(res)...)
		} else {
			err = d.db.QueryRow(ctx, sqlStr, args...).Scan(model.GetShopScanField(res)...)
		}
	} else {
		err = tx.QueryRow(sqlStr, args...).Scan(model.GetShopScanField(res)...)
	}

	return
}

// Find all the Shop from the database.
func (d *dao) FindShops(ctx context.Context, condition map[string]interface{}) (res []*model.Shop, err error) {
	// init build
	build := squirrel.Select(model.GetShopFieldString()).From(model.GetShopTableName())

	// forced master database query
	force := false
	if _, ok := condition["_force"]; ok {
		force = true
		delete(condition, "_force")
	}

	// build sql
	build, err = d.Analytic(build, condition)
	if err != nil {
		return
	}

	sqlStr, args, err := build.ToSql()
	if err != nil {
		return
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "FindShops"), log.String("sql", fmt.Sprint(sqlStr, args)))
	var rows *sql.Rows
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		if force {
			rows, err = d.db.Master().Query(ctx, sqlStr, args...)
		} else {
			rows, err = d.db.Query(ctx, sqlStr, args...)
		}
	} else {
		rows, err = tx.Query(sqlStr, args...)
	}

	if err != nil {
		return
	}

	defer rows.Close()

	// load results
	res = make([]*model.Shop, 0)
	for rows.Next() {
		// scan rows
		s := &model.Shop{}
		err = rows.Scan(model.GetShopScanField(s)...)
		if err != nil {
			return
		}

		res = append(res, s)
	}

	return
}

// Count Shop from the database.
func (d *dao) CountShop(ctx context.Context, condition map[string]interface{}) (num int, err error) {
	// init build
	build := squirrel.Select("count(*)").From(model.GetShopTableName())

	// build sql
	build, err = d.Analytic(build, condition)
	if err != nil {
		return
	}

	sqlStr, args, err := build.ToSql()
	if err != nil {
		return
	}

	// run query
	log.Info(ctx, "sql", log.String("event", "CountShop"), log.String("sql", fmt.Sprint(sqlStr, args)))
	if tx, txErr := d.GetTxFromCtx(ctx); txErr != nil {
		err = d.db.QueryRow(ctx, sqlStr, args...).Scan(&num)
	} else {
		err = tx.QueryRow(sqlStr, args...).Scan(&num)
	}

	return
}
